<html>
<head>

<title>JAM FAQ</title>

<link href="jam.css" rel="stylesheet" type="text/css" />

</style>
</head>

<body>

<h2>JAM FAQ</h2>

<br /><br />


<h3>Why do I have to write all of these JAnnotationProxies?  It seems like
such a pain.</h3>

<p>There are two ways this question can be answered; pick the answer you like best:

<ol>

  <li><u>It really isn't that difficult, especially given the advantages
they provide, and it will soon be even easier</u>.  Any decent IDE should be able to auto-generate stubs impls for a given 175 interface that you could quickly convert into a JAnnotationProxy. And when I have some extra time, I'm going to write a simple compiler that does exactly this from the command line.</li>

  <li><u>You don't actually <i>have to</i> write them</u>.  If you really, 
really don't want to do write them and are willing to live without 
strongly-typed metadata, JAM does provide a built-in alternative to 
implementing JAnntationProxy yourself.  Please refer to the javadocs on
UntypedJAnnotationProxy for details.
  </li>

</ol>
</p>

<br /><br />

<h3>How do I get more control over how JAM maps my 175 Annotations to my JAnnotationProxy</h3>

<p>Typically, when implementing a JAnnotationProxy, you just extend JAnnotationProxyBase and add your properties.  However, you are free to override
the base class' implementations of the methods on JAnnotationProxy so 
as to customize how data gets set on the proxy.
</p>

<br /><br />

<h3>My program already supports some javadoc tags that don't map very nicely to my JAnnotationProxy.  How can I continue to support those tags?</h3>

<p>You just need to take control of the mapping as described in the answer above.
</p>



<ol>

  <li><u>It really isn't that difficult, especially given the advantages
they provide, and it will soon be even easier</u>.  Any decent IDE should be able to auto-generate stubs impls for a given 175 interface that you could quickly convert into a JAnnotationProxy. And when I have some extra time, I'm going to write a simple compiler that does exactly this from the command line.</li>

  <li><u>You don't actually <i>have to</i> write them</u>.  If you really, 
really don't want to do write them and are willing to live without 
strongly-typed metadata, JAM does provide a built-in alternative to 
implementing JAnntationProxy yourself.  Please refer to the javadocs on
UntypedJAnnotationProxy for details.
  </li>

</ol>
</p>


<br /><br />

<h3>Why can I get only one JAnnotation of a given type for each 
class/method/field/whatever?</h3>

<p>
Sorry, but for better or worse, this is how JSR175 works.  In a given
scope, you only get to have one annotation declaration of a given
annotation type.  It only makes sense for JAM to do the same thing.
</p>


<br /><br />



<h3>So why doesn't JAM simply recreate the JVM's 'magic' and
synthesize implementations of 175 annotation types on the fly?</h3>

<p>That is something that has been considered.  It certainly would not be
too hard to do, but it would introduce some restrictions that would negate
many of the advantages that JAM provides.</p>

<p>First and foremost, it would prevent your annotations from classloading
under under any pre-1.5 JRE.  175 annotation types all extend 
<code>java.lang.annotation.Annotation</code>, and that class doesn't exist
in 1.4.  Right off the bat, you would have locked your code into running
under 1.5.</p>

<p>Moreover, it's not entirely clear that writing your own implementation
of a JSR175 annotation interface is a valid thing to do.  The spec doesn't
say anything about it, but it probably would strike some folks at 
Sun as being at least slightly odd.  I actually have done this with 
1.5 beta 2 and javac makes no complaints, but it's not clear at this point
that this behavior will always be supported.</p>

<p>
Finally, the hot-codegenning the annotation type impls would also remove
another subtle advantage to the JAnnotationProxy approach, which is
that it allows annotation type authors to introduce behaviors into their
annotations.  With plain JSR175, it is not possible, for example, to write
an annotation which performs a simple calculation, or contains any kind of
logic at all - it's all just dumb data.  With JAnnotationProxies, you control
the class and you can make it do whatever you want.  While this certainly
opens the door to people shooting themselves in the foot, I have never been
an advocate of protecting people from themselves.
</p>


<br /><br />


<h3>This JAnnotationProxy stuff sounds great and all, but there are some
cases where I really am going to need to be able to get at the 'real' 
annotation object.</h3>

<p>
The JAnnotation interface does have two methods, 
<code>getJavadocText()</code> and <code>getAnnotationObject</code> which
will give you the raw data if it is available.  Use of these methods is
generally discouraged, since it means your code is making assumptions 
about how the metadata is being represented and parsed.  There can be no
guarantees that these methods will actually be able to return anything 
to you.  However, they are there if you really need them for some reason.
</p>



</body>
</html>


